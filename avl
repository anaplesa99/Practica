#include<stdio.h>
#include<stdlib.h>

struct Node
{
	int key;
	struct Node *left;
	struct Node *right;
	int height;
};
int height(struct Node *N)
{
	if (N == NULL)
		return 0;
	return N->height;
}
int max(int a, int b)
{
	return (a > b)? a : b;
}
struct Node* newNode(int key)
{
	struct Node* node = (struct Node*) malloc(sizeof(struct Node));
	node->key = key;
	node->left = NULL;
	node->right = NULL;
	node->height = 1;
	return(node);
}
struct Node *rightRotate(struct Node *y)
{
	struct Node *x = y->left;
	struct Node *T2 = x->right;
	x->right = y;
	y->left = T2;
	y->height = max(height(y->left), height(y->right))+1;
	x->height = max(height(x->left), height(x->right))+1;
	return x;
}
struct Node *leftRotate(struct Node *x)
{
	struct Node *y = x->right;
	struct Node *T2 = y->left;
	y->left = x;
	x->right = T2;
	x->height = max(height(x->left), height(x->right))+1;
	y->height = max(height(y->left), height(y->right))+1;
	return y;
}
int getBalance(struct Node *N)
{
	if (N == NULL)
		return 0;
	return height(N->left) - height(N->right);
}
struct Node* insert(struct Node* node, int key)
{
	if (node == NULL)
		return(newNode(key));

	if (key < node->key)
		node->left = insert(node->left, key);
	else if (key > node->key)
		node->right = insert(node->right, key);
	else
		return node;
	node->height = 1 + max(height(node->left), height(node->right));

	int balance = getBalance(node);
	// Left Left Case
	if (balance > 1 && key < node->left->key)
		return rightRotate(node);
	// Right Right Case
	if (balance < -1 && key > node->right->key)
		return leftRotate(node);
	// Left Right Case
	if (balance > 1 && key > node->left->key)
	{
		node->left = leftRotate(node->left);
		return rightRotate(node);
	}
	// Right Left Case
	if (balance < -1 && key < node->right->key)
	{
		node->right = rightRotate(node->right);
		return leftRotate(node);
	}
	return node;
}
void preOrder(struct Node *root)
{
	if(root != NULL)
	{
		printf("%d ", root->key);
		preOrder(root->left);
		preOrder(root->right);
	}
}
int main()
{
    struct Node *root = NULL;
    int nod,opt=1, v[120],i=0,n=0,ok=0;
    int a,b,min=1000;
    root = insert(root, 10);
    root = insert(root, 20);
    root = insert(root, 30);
    root = insert(root, 40);
    root = insert(root, 50);
    root = insert(root, 25);
    while(opt)
    {
    printf("\n0.Iesire\n");
    printf("1.Adaugare nod \n");
    printf("2.Cautare nod\n");
    printf("3.Cautare cel mai mic nod\n");
    printf("4.Afisare noduri care sunt intre a si b \n");
    printf("5.Postordine\n");
    printf("Dati optiunea\n");
    scanf("%d",&opt);
    switch(opt)
    {
        case 0: break;
        case 1:
            printf("Dati nodul\n");
            scanf("%d",&nod);
            v[i++]=nod;
            n++;
            root = insert(root, nod);
        break;
        case 2:
            ok=0;
            printf("Dati nodul\n");
            scanf("%d",&nod);
            for(i=0;i<n;i++)
            if(v[i]==nod) {printf("Gasit\n");ok=1;break;}
            if(ok==0)printf("Nu am gasit\n");
        break;
        case 3:
            for(i=0;i<n;i++)
                if(v[i]<min) min=v[i];
            printf("Elementul minim este %d\n", min);
            break;
        case 4:
            printf("Dati a si b\n");
            scanf("%d",&a);
            scanf("%d",&b);
            for(i=0;i<n;i++)
                if(v[i]<=b&&v[i]>=a)
                    printf("%d",v[i]);
            break;
        case 5:
                printf("Arborele traversat in preordine este\n");
                preOrder(root);
        break;
    }
    }
    return 0;
}
